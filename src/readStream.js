import { redis } from './redis/redis.js'

const streamKey = 'PDS:demo:users:stream';        // User streams 
const trackingKey = 'PDS:demo:users:lastId';      // last processed id
const trackingCount = 'PDS:demo:users:lastCount'; // last processed count
const cardinalityKey = 'PDS:demo:users:card';     // cardinality
const top1000Key = 'PDS:demo:users:freq'          // top 1000   
const batchSize = 1000;   // Batch size 
const expireTime = 5000;  // Block for 5 seconds

async function getLastProcessedId() {
  return await redis.get(trackingKey) || '0'; // Start from the beginning if no tracking exists
}
async function getProcessedCount() {
    return await redis.get(trackingCount) || 0; // Start from the beginning if no tracking exists
}

async function processMessage(message) {
    // processing...
    //console.log(message)    
    await redis.multi().
                    pfAdd(cardinalityKey, message.message.fullname).
                    set(trackingKey, message.id).
                    incr(trackingCount).
                exec();
    await redis.sendCommand(["TOPK.ADD", top1000Key, message.message.fullname])    
}
async function readStream() {
  await redis.connect();

  let lastId = await getLastProcessedId();
  const lastProcessed = await getProcessedCount();

  if (lastId === '0') 
    console.log(`Starting from ID: ${lastId}`);
  else 
    console.log(`Resuming from ID: ${lastId}, processed is: ${lastProcessed}`);

  // TOPK.RESERVE PDS:demo:users:freq 1000 
  await redis.sendCommand(['TOPK.RESERVE', 'PDS:demo:users:freq', '100']);
  while (true) {
    try {
      const results = await redis.xRead(
        { key: streamKey, id: lastId },
        { COUNT: batchSize, BLOCK: expireTime }
      );

      if (!results) { 
        console.log('Time out! Bye bye...');
        break; 
      }

      process.stdout.write('.');
      results[0].messages.forEach(message => {
        processMessage(message)
        lastId = message.id 
      })
      //console.log(`results =`, JSON.parse(results[0].messages[0].message))
      //console.log(Object.keys(results[0].messages[0])); 
      //console.log('id=', results[0].messages[0].id); 
      //console.log('message=', results[0].messages[0].message); 
      //console.log('result =', results[0].messages[0])
    //   result[0].messages.forEach(message => {
    //     console.log(message)
    //   })
    //   for (const entry of results[streamKey]) {
    //     const [entryId, data] = entry;
    //     console.log(`Processing: ${entryId}`, data);

    //     lastId = entryId; // Update last processed ID
    //     await redis.set(trackingKey, lastId); // Persist progress
    //   }
    } catch (error) {
      console.error('Error processing stream:', error);
      break;
    }
  }

  await redis.quit();
}

await readStream();
/*
   Code template generated by copilot. 
*/